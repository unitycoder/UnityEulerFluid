#pragma kernel AdvectVelocity
#pragma kernel AdvectPressure
#pragma kernel Diffuse
#pragma kernel AddForce
#pragma kernel ComputeDivergence
#pragma kernel ComputePressure
#pragma kernel SubPressureGradient
#pragma kernel ClearPressure

#define THREAD [numthreads(8,8,8)]

StructuredBuffer<float3>   _VelocityRead;
RWStructuredBuffer<float3> _VelocityWrite;

StructuredBuffer<float>   _PressureRead;
RWStructuredBuffer<float> _PressureWrite;

StructuredBuffer<float> _VelocityDivergenceRead;
RWStructuredBuffer<float> _VelocityDivergenceWrite;

RWTexture2D<float4> _VelocityTexture;

float _VelocityDissipation;
float _PressureDissipation;

float _TimeStep;
float _Decay;
float3 _FieldSize;

float _Alpha;

float2 _MousePos;
float2 _MouseVel;

int UVToIndex(int3 uv, int3 size)
{
    uv = clamp(uv, 0, size-1);
    return uv.x + uv.y * size.x; + uv.z * size.x * size.y;
}

int3 GetBackwardUV(int3 uv, float dt)
{
    int id = UVToIndex(uv, _FieldSize);
    return uv - dt * _VelocityRead[id];
}

THREAD
void ClearPressure (uint3 id : SV_DispatchThreadID)
{
    int3 uv = id.xyz;
    _PressureWrite[UVToIndex(uv, _FieldSize)] = 0;
}

THREAD
void AdvectVelocity (uint3 id : SV_DispatchThreadID)
{
    int3 uv = id.xyz;
    int3 backUV = GetBackwardUV(uv, _TimeStep);
    _VelocityWrite[UVToIndex(uv, _FieldSize)] = _VelocityRead[UVToIndex(backUV, _FieldSize)] * _VelocityDissipation;
}

THREAD
void AdvectPressure (uint3 id : SV_DispatchThreadID)
{
    int3 uv = id.xyz;
    int3 backUV = GetBackwardUV(uv, _TimeStep);
    _PressureWrite[UVToIndex(uv, _FieldSize)] = _PressureRead[UVToIndex(backUV, _FieldSize)] * _PressureDissipation;
}
THREAD
void Diffuse (uint3 id : SV_DispatchThreadID)
{
    
}

THREAD
void AddForce (uint3 id : SV_DispatchThreadID)
{
    int3 uv = id;
    int2 pos = _MousePos * _FieldSize.xy;
    float3 current = _VelocityRead[UVToIndex(uv, _FieldSize)];

    if(distance(uv.xy, pos) < 50)
    {
         current += float3(_MouseVel,0);
    }
    if(uv.x == 0 || uv.y == 0 || uv.z == 0 || uv.x == _FieldSize.x-1 || uv.y == _FieldSize.y-1 || uv.z == _FieldSize.z) current = 0;

    _VelocityWrite[UVToIndex(uv, _FieldSize)] = current;
}

THREAD
void ComputeDivergence (uint3 id : SV_DispatchThreadID)
{
    int3 uv = id.xyz;
    int3 u = int3(0, 1, 0);
    int3 d = int3(0,-1, 0);
    int3 l = int3(1, 0, 0);
    int3 r = int3(-1,0, 0);
    int3 f = int3(0, 0, 1);
    int3 b = int3(0, 0,-1);
    float div = 0;
    div += _VelocityRead[UVToIndex(uv + u, _FieldSize)].x - _VelocityRead[UVToIndex(uv + d, _FieldSize)].x;
    div += _VelocityRead[UVToIndex(uv + r, _FieldSize)].y - _VelocityRead[UVToIndex(uv + l, _FieldSize)].y;
    div += _VelocityRead[UVToIndex(uv + f, _FieldSize)].z - _VelocityRead[UVToIndex(uv + b, _FieldSize)].z;

    div *= 0.5f;
    
    _VelocityDivergenceWrite[UVToIndex(uv, _FieldSize)] = div;
}

THREAD
void ComputePressure (uint3 id : SV_DispatchThreadID)
{
    int3 uv = id.xyz;
    int3 u = int3(0, 1, 0);
    int3 d = int3(0,-1, 0);
    int3 l = int3(1, 0, 0);
    int3 r = int3(-1,0, 0);
    int3 f = int3(0, 0, 1);
    int3 b = int3(0, 0,-1);
    bool is3D = _FieldSize.z > 1;
    float div = _VelocityDivergenceRead[UVToIndex(uv, _FieldSize)];
    float p = 0;
    
    p += _PressureRead[UVToIndex(uv + u, _FieldSize)] + _PressureRead[UVToIndex(uv + d, _FieldSize)];
    p += _PressureRead[UVToIndex(uv + r, _FieldSize)] + _PressureRead[UVToIndex(uv + l, _FieldSize)];
    if(is3D) p += _PressureRead[UVToIndex(uv + f, _FieldSize)] + _PressureRead[UVToIndex(uv + b, _FieldSize)];

    float beta = is3D?6:4;
    p = (p + _Alpha * div)/beta;

    _PressureWrite[UVToIndex(uv, _FieldSize)] = p;
}

THREAD
void SubPressureGradient (uint3 id : SV_DispatchThreadID)
{
    int3 uv = id.xyz;
    int3 u = int3(0, 1, 0);
    int3 d = int3(0,-1, 0);
    int3 l = int3(1, 0, 0);
    int3 r = int3(-1,0, 0);
    int3 f = int3(0, 0, 1);
    int3 b = int3(0, 0,-1);
    float3 vel = _VelocityRead[UVToIndex(uv, _FieldSize)];
    float3 gradient = 0;
    
    gradient.x = _PressureRead[UVToIndex(uv + u, _FieldSize)] - _PressureRead[UVToIndex(uv + d, _FieldSize)];
    gradient.y = _PressureRead[UVToIndex(uv + r, _FieldSize)] - _PressureRead[UVToIndex(uv + l, _FieldSize)];
    gradient.z = _PressureRead[UVToIndex(uv + f, _FieldSize)] - _PressureRead[UVToIndex(uv + b, _FieldSize)];
    gradient *= 0.5f;

    
    _VelocityWrite[UVToIndex(uv, _FieldSize)] = vel - gradient;

    _VelocityTexture[uv.xy] = float4(vel - gradient,1);
}